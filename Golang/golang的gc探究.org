#+LATEX_CLASS: jacksoncy-org-article

#+TITLE: Golang 的 GC 探究

* 变量的生命同期
** 栈中的变量
   栈中的变量就是一个代码块中的变量(内存的申请与释放都是由系统来做）。在 =Golang= 中由于不容许重复定义变量，所以我们可以看一下 =C++= 的例子：

#+BEGIN_SRC C++
  #include <iostream>

  int main()
  {
      int a{3};
      {
          int a{5};
          std::cout << a << " ,Pointer: " << &a << std::endl;
      }
      std::cout << a << " ,Pointer: " << &a << std::endl;
      return 0;
  }
#+END_SRC

运行的结果如下：

[[file:test.png]]

可以看到，不同栈中的变量不会是同一个，栈中的变量会随着代码块的结束而消亡（压栈与弹栈过程）。所以有时候我们可以用代码块特性来做一些局部变量的控制。

** 堆中的变量
   堆中的变量就意味着是由程序员主动向系统申请的内存地址，一般是由特定关键字来操作（比如 =new= 、 =malloc= )，同时也意味着内存的回收工作也是由程序员来做。其生命周期是一直到回收为止，
如果没有回收就是内存泄漏。所以 =GC= 的主要工作是回收这部分变量的内存。
** 变量逃逸
   =Golang= 在一定程度消除了堆和栈的区别，因为 =Golang= 在编译的时候进行逃逸分析，来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上。
所以在 =Golang= 中你可以在一个函数中返回一个局部变量。就像下面这样：

#+BEGIN_SRC go
  func RetSome() string {
      str := "this is a string"
      return str
  }
#+END_SRC

所以我们要注意的是虽然这种写法是正确的，但在实际编程中是万万不可取的(因为每一次变量逃逸都涉及两次内存分配，不但性能上有损失，而且不符编程规范)。

* 引用计数
  引用计数在现代语言的 =GC= 中已很少使用了，但是这个技术在目前的内存管理技术中是非常实用的。引用计数的简单描述就是让每一个被管理的对象与一个引用计数器关联在一起，计数器记录着该对象当前被引用的次数，
当对象被引用一次则计数器加 1,当对象解引用一次则计数器减 1。当计数器的值降到 0 时则认为对象消亡，可以回收。每个计数器只记录了被管理对象的局部信息--被引用的次数。

  引用计数法有个缺陷就是不能解决循环引用的问题。循环引用是指对象 =A= 和对象 =B= 互相持有对方的引用。这样两个对象的引用计数都不是 0，因此永远不能被收集。

  所以在 =C++= 中有两个智能指针 -- 强引用型(=std::shared_ptr=)、弱引用型(=std::weak_ptr=)。

* Golang 的内存分配（Tcmalloc)
  内存分配就目前来说优秀的大概就是 =glibc= 中的 =ptmalloc= 、 =facebook= 的 =jemalloc= 、 =google= 的 =tcmalloc= 。其中以 =ptmalloc= 应用最广泛，但后两者以架构优秀、性能高、不易出现内存碎片而
出名。而 =Golang= 出自 =google= 之手，内存分配自然是站在 =tcmalloc= 这个巨人的肩膀上啦。

* Golang 的 GC
  =Golang= 的 =GC= 的算法大概有这么几个阶段吧：
    - v1.1 版本的 =Mark&Sweep= ，这个算法最大的问题就在于 =STW= (=Stop The World=)。
    - v1.3 版本的 =Mark STW=, =Sweep= 并行。
    - v1.5 版本的三色标记法。
    - v1.8 =hybrid write barrier= 。
    - v1.9 =goroutine= 级别的 =GC= 。
    
* 参考文档
  #+BEGIN_QUOTE
  [[http://goog-perftools.sourceforge.net/doc/tcmalloc.html][Thread-Caching Malloc]]

  [[https://github.com/qyuhen/book/blob/master/Go%201.5%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%EF%BC%88%E4%B9%A6%E7%AD%BE%E7%89%88%EF%BC%89.pdf][Go 1.5 源码剖析]]

  [[https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)][垃圾回收]]  

  [[https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md][Eliminate STW stack re-scanning]]
  #+END_QUOTE
