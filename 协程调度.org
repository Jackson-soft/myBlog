#+LATEX_CLASS: jacksoncy-org-article

#+TITLE: 协程调度

* 简单科普
*** 并发与并行
    [[./coroutine.png]]
    并发讲究的是任务的切分（就如 =Nginx= 里将一个完整的 =HTTP= 请求拆分成 11 个任务片段），提高系统并发量。
    并行是同时执行任务，提高系统的吞吐量（前提必须是硬件的多核）。
*** 硬件并行架构
    摩尔定律：积体电路上可容纳的电晶体（晶体管）数目，约每隔两年便会增加一倍。
    近年来随着摩尔定律的失效，各 =CPU= 厂商开始多核心架构设计进而带动软件的并行化。
*** 协程与线程
    进程是程序的基本执行实体，线程是独立调度和分派的基本单位。
    
    协程最初在 1963 年被公开提出（PS：这个比进程概念要早）。
    对于进程、线程，都是由内核进行调度，有 =CPU= 时间片的概念，进行 *抢占式调度* （当然还有其他多种调度算法，毕竟线程调度是操作系统非常复杂的一部分）。

    对于协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 =CPU= 控制权切换到其他进程/线程，
通常只能进行 *协作式调度* ，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到(这是标准协程的实现方法，在 =goroutine= 的实现中则有类似于内核线程调度的算法)。
*** =coroutine= 类型
    - =stackfull= 协程 :: 易用性和灵活性非常高，但是内存使用过大。
      - 对称协程只提供一种传递操作，用于在协程间直接传递控制，协程每次需要挂起时需要指定一个明确切换的目标协程，也就是说控制权只能在协程间跳转。
      - 非对称协程提供调用和挂起两种操作，挂起时控制权返回给调用者。被调用的协程可以看成时从属于调用者，这种协程在日常使用中更常见，上文的例子就属于非对称式。
    - =stackless= 协程 :: 切换效率和内存利用率很高，更加轻量，但是使用上限制较多。（PS：协程未来的究级进化体，C#的 async/await 之类）

* 线程调度
*** 1:1
    一个用户级线程对应一个内核级线程，这时可以利用多核，但是上下文 =switch= 很慢。
*** N:1
    N 个用户级线程对应一个内核级线程， =context= 上下文切换确实很快，但是无法真正的利用多核。
*** M:N
    M 个用户级线程对应 N 个内核级线程
* 协程调度
  这里主要说的是 =Golang= 与 =C++= 的调度方式。
  在 =Golang= 里协程叫 =goroutine= ，

  [[./goroutine.png]]

  =C++= 的协程实现方式是非对称式，第一类级，无栈式。


参考文档：

[[https://www.amazon.cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-%E8%A5%BF%E5%B0%94%E4%BC%AF%E6%9F%A5%E8%8C%A8/dp/B004OQE8BI/ref=sr_1_1?ie=UTF8&qid=1509954065&sr=8-1&keywords=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5][操作系统概念(第 7 版)]]

[[http://llvm.org/docs/Coroutines.html][Coroutines in LLVM]]

[[https://github.com/qyuhen/book/blob/master/Go%201.5%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%EF%BC%88%E4%B9%A6%E7%AD%BE%E7%89%88%EF%BC%89.pdf][Go 1.5 源码剖析]]

[[http://www.modernescpp.com/index.php/coroutines][C++20 Coroutines]]
