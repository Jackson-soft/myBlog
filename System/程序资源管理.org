#+LATEX_CLASS: jacksoncy-org-article

#+TITLE: 编程中的资源管理

* 简要说明
在计算机运行的过程中所用到的诸如 CPU 时间片、内存、进程、线程等等都可以说是资源。而编程最主要的目的就是合理运用这些资源来完成特定的任务。在这些资源的管理过程中主要涉及到创建、移动、回收。

* 资源的创建
这里主要是申请。

** RAII(资源获取即初始化)
写过 /C/ 或 /C++/ 的都听过这么一个段子：手持两把锟斤拷，口中疾呼烫烫烫。这就是资源未初始化的问题。其实烫烫烫的结果应该是最好的，如果恰好这块内存上有数据那才是最致命的。
我们都知道一个变量在使用前要有声明、定义、初始化过程。而 =RAII= 就是定义一个类的实例的话，编译器会保证自动调用类的构造函数（如果类中没有，编译器会默认生成一个构造函数）。在类消亡时编译器同样保证
调用类的析构函数。

** 内存碎片
内存碎片主要是内存在不断的 =new= 、 =delete= 的过程中如果没有一个良好的内存分配架构系统是极易出现的内存不连续的状态。内存碎片会极大的影响程序的性能和浪费内存。目前比较好的内存管理库有
FreeBSD 的 =jemalloc= 和 Google 的 =tcmalloc= 。

* 资源的运输

** 移动


** 传参

* 资源的使用
这一块其实最主要的问题就是越界访问。越界访问的定义其实就是非礼毋视（你用了本不属于你的东西）。在 /C/ 和 /C++/ 的原生数组（字符串也是数组的一种，只是以'\0'标识了数组的结尾而已）是一块连续的内存。
我们在访问的时候如果没有小心注意数组的个数的话，很容易就越界了。所以很多现代语言都会对 /C/ 语言的数组做一层封装。比如 =std::array= 、 =std::vector= 。而 go 语言的数组跟切片长这样：

#+BEGIN_SRC go
type slice struct {
	array unsafe.Pointer //C 语言的数组的首元素地址
	len   int //数据的长度
	cap   int //切片的容量
}

type arraytype struct {
	typ   _type
	elem  *_type
	slice *_type
	len   uintptr
}

type stringStruct struct {
	str unsafe.Pointer
	len int
}
#+END_SRC

* 资源的消亡
相比于上面两个过程，资源的回收显然尤为的困难。内存泄漏是最为长见的回收问题。为了应对内存回收问题，人们想到了引用计数、GC 等等解决方案。

** 引用计数

** 语言级垃圾回收器
