#+LATEX_CLASS: jacksoncy-org-article

#+TITLE: 编程中的资源管理

* 简要说明
这篇文章主要想说的就是天下没有免费的午餐。

在计算机运行的过程中所用到的诸如 CPU 时间片、内存、进程、线程等等都可以说是资源。而编程最主要的目的就是合理运用这些资源来完成特定的任务。在这里主要指内存方面的管理，不涉及诸如 CPU 时间
片、进程、线程、文件描述符等等非可控资源。

还有一点就是所有的切换都是有性能代价的，都有上下文、数据的压栈跟弹栈。比如 CPU 核的切换、CPU 时间片的切换、函数调用、代码块、进程切换、线程切换等等。
例如在 /Nginx/ 中所有的 /worker/ 进程跟是跟 /CPU/ 核绑定而且都是建议 /worker/ 的数量跟 /CPU/ 核数一样来优化性能。

* 资源的创建
申请资源有时候也是一种性能开销很大的操作。所以就有了各种池式操作来避免不断的申请销毁操作。

** RAII(资源获取即初始化)
写过 /C/ 或 /C++/ 的都听过这么一个段子：手持两把锟斤拷，口中疾呼烫烫烫。这就是资源未初始化的问题。其实烫烫烫的结果应该是最好的，如果恰好这块内存上有数据那才是最致命的。

我们都知道一个变量在使用前要有声明、定义、初始化过程。一个变量在使用前一定一定要做好初始化工作，编译器是没有义务来保证变量的的初始化工作的。在这一块我倒觉得 /Go/ 的编译器为我们做了很多工作，在
/Go/ 中如果我们定义一个变量的话，编译器是会用变量类型的零值来初始化该变量（其实这个动作我个人觉得是仁者见仁，智者见智）。

而 =RAII= 就是定义一个类的实例的话，编译器会保证自动调用类的构造函数（如果类中没有，编译器会默认生成一个构造函数），在类消亡时编译器同样保证调用类的析构函数，当然如果类中有堆内存要在析构函数中
释放，不然一样会内存泄漏。

/C++/ 的 /new/ 有这么一种操作，可以就地初始化：

#+BEGIN_SRC c++
auto pp = new int(8);
std::cout << *pp << std::endl;
#+END_SRC

这个操作相当于 /Go/ 中的 /make/ ，即申请内存+初始化过程。所以 /make/ 的应用场景就只能是切片、 /chan/ 、 /map/ 这些底层需要申请内存的类型。

** 内存碎片
内存碎片主要是内存在不断的 =malloc= 、 =delete= 的过程中如果没有一个良好的内存分配架构系统是极易出现的内存不连续的状态。内存碎片会极大的影响程序的性能和浪费内存。目前比较好的内存管理库有
/FreeBSD/ 的 =jemalloc= 和 /Google/ 的 =tcmalloc= 。

* 资源的运输

** 移动
移动有两种语义： =move= 、 =copy= ， 相当于剪切和复制。有些语言实现了两种，有些语言实现了一种。从性能上来讲, =move= 的性能要高于 =copy= ，尤其是复杂的结构。因为从流程上来讲，编译器要拷贝一个对象，
要依次调用构造函数、拷贝构造函数、析构函数。而 =move= 只需要把对象剪切到新的地址上，被 =move= 后的对象依然合法并处于未定义状态。而在调用拷贝构造函数的时候将会有两种处理方式：
*** 浅拷贝
浅拷贝就是简单的值拷贝。基本的数据类型是完全没有问题的，只有在类中有指针或引用的情况下会出问题，因为浅拷贝只拷贝数据的值，而非内容，这样就会造成两个对象的指针成员指向同一块内存地址。如果我们修改了其中一
对象中指针的内容，就会造成两个对象的指针内容同步修改，这个后果还是挺严重的。
*** 深拷贝
深拷贝就是在对象中有指针或引用时，将新申请内存，并拷贝指针指向的内容。深拷贝之后的两个对象是完全独立的，没有任何瓜葛。我们可以放心大胆的操作任一对象。
** 传参
一般在函数传参的时候有这么几种传参方式：值传递、引用传递、指针传递（其实也是值传递）。基本数据类型值传递完全没有问题，大型数据类型尽量用另外两种方式。

*Go 的传参只有值传递，而且是浅拷贝。* 怎么证明呢？

#+BEGIN_SRC go
package main

import "fmt"

func main() {
	testValue()
}

type Text struct {
	name string
	age  int
}

type MyTest struct {
	vl int
	tt *Text
}

func testValue() {
	test := MyTest{
		vl: 0,
		tt: &Text{},
	}
	fmt.Printf("%p, %p\n", &test, test.tt)
	testValue1(test)
	fmt.Println(test, test.tt.age)
}

func testValue1(v MyTest) {
	fmt.Printf("%p, %p\n", &v, v.tt)
	v.vl = 33
	v.tt.age = 44
	fmt.Println(v, v.tt.age)
}
#+END_SRC

结果如下：

[[./testValue.png]]

从结果中我们看到参数与入参的地址不同，说明是拷贝过副本的值传递。同时我们也看到结构体中的指针是址却是同一个地址，很明显编译器执行的是浅拷贝，只拷贝了指针的值，并未重新分配内存。

但这里却有一个例外，那就是数组。在 /Go/ 中数组在传参的时候是深拷贝，所以在 /Go/ 里尽量用切片而非数组，不但方便而且性能高，同样坑也会多:)。

/Go/ 的值传递方式是需要我们注意的，这里面有很多坑 ：)。比如：

#+BEGIN_SRC go
test := []Text{{
	name: "xx", age: 4,
}}
for _, vl := range test {
	vl.age = 5
}
fmt.Println(test)
#+END_SRC

这里只是修改了副本，所以原值修改失败。

** 出参
出参即是函数的返回值，一般是值拷贝。出参是绝对是不容许返回局部变量指针。因为局部变量的作用域为函数内部，函数执行结束，栈上的局部变量会销毁，内
存释放，如果将局部变量的指针返回出来就是野指针，其危险程度比使用未初始化的指针更严重。

#+BEGIN_SRC c++
char* returnValue()  
{  
    char str[]="Hello world.";  
    return str;  
} 
#+END_SRC

但 /Go/ 中这种写法却是可以的。因为 /Go/ 的编译器会帮我们在堆上重新分配内存并返回（编译器的这个操作不但是坑，而且是误导，尽量不要这么来做）。

* 资源的使用
这一块其实最主要的问题就是越界访问。

越界访问的定义其实就是非礼毋视（你用了本不属于你的东西）。原生数组（字符串也是数组的一种，只是以'\0'标识了数组的结尾而已）是一块连续的内存。在我们访问数组元素的时候就是第一个元素
的内存地址逐一加一来访问的，如果不小心没有注意数组的个数的话，访问了数组外面的内存地址，这就是越界。所以很多现代语言都会对 /C/ 语言的数组做一层封装。比如 /C++/ 的 =std::array= 、 
=std::vector= 。

而 /Go/ 语言的数组跟切片长这样：

#+BEGIN_SRC go
type stringStruct struct {
	str unsafe.Pointer
	len int
}

type slice struct {
	array unsafe.Pointer //C 语言的数组的首元素地址
	len   int //数据的长度
	cap   int //切片的容量
}
#+END_SRC

很多现代语言也都有类似这样一层封装，用以防止数组的越界访问。

我们再来看看 /Nginx/ 的数组：

#+BEGIN_SRC c
typedef struct {
    void        *elts; //数组使用的内存块的起始地址
    ngx_uint_t   nelts; //当前内存块已存在的元素个数
    size_t       size; //数组大小
    ngx_uint_t   nalloc; //内存块最多能容纳的数组元素个数，因此，内存块的结束地址= elts+nalloc*size
    ngx_pool_t  *pool; //使用的内存所在的内存池
} ngx_array_t;
#+END_SRC

其思路一模一样，只不过 /Nginx/ 中所有的内存分配都是走内存池而已。而 /Go/ 有 /Tcmalloc/ 加持，所以内存池在 /runtime/ 级别实现的。

* 资源的消亡
相比于上面两个过程，资源的回收显然尤为的困难。因为堆内存的生命周期太难控制了，所以内存泄漏是最为常见的资源回收问题。为了应对内存回收问题，人们想到了引用计数、GC 等等解决方案。

** 引用计数
引用计数主要是为了管理祼指针的内存回收问题。
** 语言级垃圾回收器
/GC/ 这玩意是一个浩大的系统工程。这里就不展开讲了 :)
