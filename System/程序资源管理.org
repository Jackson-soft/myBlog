#+LATEX_CLASS: jacksoncy-org-article

#+TITLE: 编程中的资源管理

* 简要说明
这篇文章主要想说的就是天下没有免费的午餐。
在计算机运行的过程中所用到的诸如 CPU 时间片、内存、进程、线程等等都可以说是资源。而编程最主要的目的就是合理运用这些资源来完成特定的任务。在这些资源的管理过程中主要涉及到创建、移动、回收。在这里主
要指内存方面的管理，不涉及诸如 CPU 时间片、进程、线程、文件描述符等等非可控资源。
栈是由编译器来做资源申请与销毁。
堆是由程序员来做资源申请与销毁。

* 资源的创建
申请资源有时候也是一种性能开销很大的操作。所以就有了各种池式操作来避免不断的申请销毁操作。

** RAII(资源获取即初始化)
写过 /C/ 或 /C++/ 的都听过这么一个段子：手持两把锟斤拷，口中疾呼烫烫烫。这就是资源未初始化的问题。其实烫烫烫的结果应该是最好的，如果恰好这块内存上有数据那才是最致命的。
我们都知道一个变量在使用前要有声明、定义、初始化过程。而 =RAII= 就是定义一个类的实例的话，编译器会保证自动调用类的构造函数（如果类中没有，编译器会默认生成一个构造函数）。在类消亡时编译器同样保证
调用类的析构函数。

#+BEGIN_SRC c++
	auto pp = new int(8);
	std::cout << *pp << std::endl;
#+END_SRC

/C++/ 的 /new/ 有这么一种操作，可以就地初始化。在类的实例化过程中编译保证会调用构造函数，在消毁对象时保证调用析构函数。当然如果类中有堆内存要在析构函数中释放，不然一样会内存泄漏。

** 内存碎片
内存碎片主要是内存在不断的 =new= 、 =delete= 的过程中如果没有一个良好的内存分配架构系统是极易出现的内存不连续的状态。内存碎片会极大的影响程序的性能和浪费内存。目前比较好的内存管理库有
FreeBSD 的 =jemalloc= 和 Google 的 =tcmalloc= 。

* 资源的运输

** 移动
移动有两种语义： =move= 、 =copy= ， 相当于剪切和复制。有些语言实现了两种，有些语言实现了一种。从性能上来讲, =move= 的性能要高于 =copy= ，尤其是复杂的结构。因为从流程上来讲，编译器要拷贝一个对象，
要依次调用构造函数、拷贝构造函数、析构函数。而 =move= 只需要把对象剪切到新的地址上，被 =move= 后的对象依然合法并处于未定义状态。而在调用拷贝构造函数的时候将会有两种处理方式：
*** 浅拷贝
浅拷贝就是简单的值拷贝。基本的数据类型是完全没有问题的，只有在类中有指针的情况下会出问题，因为指针只拷贝了指针的值，而非内容。这样就是造成两个对象的指针成员指向同一块内存地址。
*** 深拷贝
深拷贝就是在对象中有指针或引用时，将新申请内存，并拷贝指针指向的内容。深拷贝之后的两个对象是完全独立的，没有任何瓜葛。
** 传参
一般在函数传参的时候有这么几种传参方式：值传递、引用传递、指针传递（其实也是值传递）。
*Go 的传参只有值传递，而且是浅拷贝。* 怎么证明呢？
#+BEGIN_SRC go
package main

import "fmt"

func main() {
	testValue()
}

type Text struct {
	name string
	age  int
}

type MyTest struct {
	vl int
	tt *Text
}

func testValue() {
	test := MyTest{
		vl: 0,
		tt: &Text{},
	}
	fmt.Printf("%p, %p\n", &test, test.tt)
	testValue1(test)
	fmt.Println(test, test.tt.age)
}

func testValue1(v MyTest) {
	fmt.Printf("%p, %p\n", &v, v.tt)
	v.vl = 33
	v.tt.age = 44
	fmt.Println(v, v.tt.age)
}
#+END_SRC

结果如下：
[[./testValue.png]]
从结果中我们看到参数与入参的地址不同，说明是拷贝过副本的值传递。同时我们也看到结构体中的指针是址却是同一个地址，很明显编译器执行的是浅拷贝，只拷贝了指针的值，并未重新分配内存。

/go/ 的值传递方式是需要我们注意的，这里面有很多坑 ：)。比如：
#+BEGIN_SRC go
	test := map[string]Text{"a": Text{}, "b": Text{}}
	for _, vl := range test {
		vl.age = 333
	}
	fmt.Println(test)
#+END_SRC

这里只是修改了副本，所以修改失败。

* 资源的使用
这一块其实最主要的问题就是越界访问。越界访问的定义其实就是非礼毋视（你用了本不属于你的东西）。在 /C/ 和 /C++/ 的原生数组（字符串也是数组的一种，只是以'\0'标识了数组的结尾而已）是一块连续的内存。
我们在访问的时候如果没有小心注意数组的个数的话，很容易就越界了。所以很多现代语言都会对 /C/ 语言的数组做一层封装。比如 =std::array= 、 =std::vector= 。而 go 语言的数组跟切片长这样：

#+BEGIN_SRC go
type slice struct {
	array unsafe.Pointer //C 语言的数组的首元素地址
	len   int //数据的长度
	cap   int //切片的容量
}

type stringStruct struct {
	str unsafe.Pointer
	len int
}
#+END_SRC

很多语言也都类似这样一层封装，用以保证数组的越界访问。

* 资源的消亡
相比于上面两个过程，资源的回收显然尤为的困难。因为堆内存的生命周期太难控制了，所以内存泄漏是最为常见的资源回收问题。为了应对内存回收问题，人们想到了引用计数、GC 等等解决方案。

** 引用计数

** 语言级垃圾回收器
/GC/ 这玩意是一个浩大的系统工程。这里就不展开讲了 :)
